<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Introduction</section>
				<section>Definition</section>
				<section>
					<p>
						Garbage is not memory leak. Garbage will always be freed sooner or later by the garbage collector.

Memory leak is actually objects which still has a reference kept in a variable/constant/property somewhere, but that variable/constant/property is never used again and never goes out of scope. And FYI, JavaScript is not the only one which can keep an object reference. DOM can also do that.

However, if your application produces garbage too fast, the garbage collector may not free the memory used by garbage fast enough. This will apper that the application keep consuming memory, but it's not memory leak. It's just that the rate of the garbage produced by an application is higher than the rate of garbage recycling.
					</p>
				</section>
				<section>Examples w/Mitigation</section>
				<section>Global Variables</section>
				<section>
				<pre>
					<code class="language-javascript">
						// Global Variable
						var globalVar = 'I am a global variable';

						// Mitigation
						(function() {
							var localVar = 'I am a local variable';
						})();
					</code>
				</pre>
			</section>
			<section>
				<pre>
					<code class="language-javascript">
						function createLeak() {
							leak = "This is a leak!"; // Declares a global variable unintentionally
						}

						createLeak();
						console.log(window.leak); // Accessible globally

						// Mitigation
						function createLeak() {
							let leak = "No leak here!"; // Use `let`, `const`, or `var`
						}
					</code>
				</pre>
			</section>
			<section>
				<pre>
					<code class="language-javascript">
						// This global variable will persist for the life of the program
						// and cause a memory leak if it holds onto references to objects
						// that are no longer needed.
						let data = [];

						function fetchData() {
							data = getDataFromServer();
						}

						// To prevent the memory leak, we need to set the global variable
						// to null when it is no longer needed.
						function clearData() {
							data = null;
						}
						</code>
				</pre>
			</section>
				<section>Event Listeners</section>
				<section>
				<pre>
					<code class="language-javascript">
// Event Listener
document.getElementById('button').addEventListener('click', function() {
	console.log('Button clicked');
});

// Mitigation
const button = document.getElementById('button');
button.addEventListener('click', function() {
	console.log('Button clicked');
});
					</code>
				</section>
				<section>Closures</section>
				<section>
					<pre>
						<code class="language-javascript">
							function outerFunction() {
								let largeArray = new Array(1000000).fill('memory leak');
								return function innerFunction() {
										console.log(largeArray);
								};
						}
						const leak = outerFunction(); // `largeArray` is retained in memory.
</code>
					</pre>
					</section>
					<section>
				<pre>
					<code class="language-javascript">
						function closureLeak() {
							let largeArray = new Array(1000000).fill("leak");
							return function () {
									console.log(largeArray[0]); // Large array is kept alive
							};
					}

					let leakyFunc = closureLeak();
					// Even when closureLeak() is done, `largeArray` remains in memory

					function closureFix() {
						let largeArray = new Array(1000000).fill("leak");
						return function () {
								console.log("No need to hold onto largeArray.");
						};
				}
				let fixedFunc = closureFix();
	</code>
	</pre>
				</section>
				<section>
					<pre>
						<code class="language-javascript">
							var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing)
      console.log("hi");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);
								</code>
					</pre>
				</section>
				<section>
					<pre>
						<code class="language-javascript">
							var closureVar = {};
doWork(function callback() {
  var data = closureVar.usefulData;
  // Do a bunch of work
  closureVar = null;
});
						</code></pre>
				</section>
				<section>Detached DOM Nodes</section>
				<section>Timers and Intervals</section>
				<section>Tooling</section>
				<section>Chrome DevTools</section>
				<section>MemLab</section>
				<section>Fuite</section>
				<section>WeakMap & WeakSet</section>
				<section>Closing</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
